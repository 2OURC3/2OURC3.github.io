<!doctype html><html>
    <head>
      <meta http-equiv="content-type" content="text/html; charset=utf-8">
      <title>ASM</title>
      <meta name="generator" content="CherryTree">
      <link rel="stylesheet" href="res/styles3.css" type="text/css" />
    </head>
    <body><div class='page'><h1 class='title'>ASM</h1><br/><h1>General :</h1><br /><br />An assembly program can be divided into three sections :<br />▪ The data section<br />▪ The bss section, and<br />▪ The text section.<br /><br />Assembly language programs consist of three types of statements :<br />▪ Executable instructions or instructions,<br />▪ Assembler directives or pseudo-ops, and<br />▪ Macros.<br /><br /><br />Basic FORMAT is =&gt; [label] mnemonic [operands] [;comment]<br /><br />Following are some examples of typical assembly language statements :<br /><br />⇒ INC COUNT ; Increment the memory variable COUNT<br />⇒ MOV TOTAL, 48 ; Transfer the value 48 in the memory variable TOTAL<br />⇒ ADD AH, BH ; Add the content of the BH register into the AH register<br />⇒ AND MASK1, 128 ; Perform AND operation on the variable MASK1 and 128<br />⇒ ADD MARKS, 10 ; Add 10 to the variable MARKS<br />⇒ MOV AL, 10 ; Transfer the value 10 to the AL register<br /><br /><br /><h1>Memory segments</h1><br />We can specify various memory segments as :<br /><br />▪ Data segment − It is represented by .data section and the .bss.<br />The .data section is used to declare the memory region, where data elements are stored for the program.<br />This section cannot be expanded after the data elements are declared and it remains static throughout the program.<br />The .bss section is also a static memory section that contains buffers for data to be declared later in the program.<br />This buffer memory is zero-filled.<br />▪ Code segment − It is represented by .text section. This defines an area in memory that stores the instruction codes. This is also a fixed area.<br />▪ Stack − This segment contains data values passed to functions and procedures within the program.<br /><br /><br /><h1>Processor Registers</h1><br /><br />There are ten 32-bit and six 16-bit processor registers in IA-32 architecture. The registers are grouped into three categories .<br />▪ General registers,<br />▪ Control registers, and<br />▪ Segment registers.<br /><br />The general registers are further divided into the following groups .<br />▪ Data registers,<br />▪ Pointer registers, and<br />▪ Index registers.<br /><br /><br /><h1>Data Registers</h1><br /><br />Four 32-bit data registers are used for arithmetic, logical, and other operations. These 32-bit registers can be used in three ways −<br />▪ As complete 32-bit data registers: EAX, EBX, ECX, EDX.<br />▪ Lower halves of the 32-bit registers can be used as four 16-bit data registers: AX, BX, CX and DX.<br />▪ Lower and higher halves of the above-mentioned four 16-bit registers can be used as eight 8-bit data registers: AH, AL, BH, BL, CH, CL, DH, and DL.<br /><br /><br />AX is the primary accumulator; it is used in input/output and most arithmetic instructions. For example, in multiplication operation,<br />one operand is stored in EAX or AX or AL register according to the size of the operand.<br /><br />BX is known as the base register, as it could be used in indexed addressing.<br /><br />CX is known as the count register, as the ECX, CX registers store the loop count in iterative operations.<br /><br />DX is known as the data register. It is also used in input/output operations. It is also used with AX register along with DX for multiply and divide<br />operations involving larges values.<br /><br /><br /><h1>Pointer Registers</h1><br /><br />The pointer registers are 32-bit EIP, ESP, and EBP registers and corresponding 16-bit right portions IP, SP, and BP. There are three categories of pointer<br />registers :<br />▪ Instruction Pointer (IP) − The 16-bit IP register stores the offset address of the next instruction to be executed. IP in association with the CS<br />register (as CS:IP) gives the complete address of the current instruction in the code segment.<br />▪ Stack Pointer (SP) − The 16-bit SP register provides the offset value within the program stack. SP in association with the SS register (SS:SP)<br />refers to be current position of data or address within the program stack.<br />▪ Base Pointer (BP) − The 16-bit BP register mainly helps in referencing the parameter variables passed to a subroutine. The address in SS<br />register is combined with the offset in BP to get the location of the parameter. BP can also be combined with DI and SI as base register for special<br />addressing.<br /><br /><br /><h1>Index Registers<br /></h1><br />The 32-bit index registers, ESI and EDI, and their 16-bit rightmost portions. SI and DI, are used for indexed addressing and sometimes used in addition<br />and subtraction. There are two sets of index pointers −<br />▪ Source Index (SI) − It is used as source index for string operations.<br />▪ Destination Index (DI) − It is used as destination index for string operations.<br /><br /><br /><h1>Control Registers<br /></h1><br /><br />The 32-bit instruction pointer register and the 32-bit flags register combined are considered as the control registers.<br />Many instructions involve comparisons and mathematical calculations and change the status of the flags and some other conditional instructions test<br />the value of these status flags to take the control flow to other location.<br /><br />The common flag bits are:<br />▪ Overflow Flag (OF) − It indicates the overflow of a high-order bit (leftmost bit) of data after a signed arithmetic operation.<br />▪ Direction Flag (DF) − It determines left or right direction for moving or comparing string data. When the DF value is 0, the string operation<br />takes left-to-right direction and when the value is set to 1, the string operation takes right-to-left direction.<br />▪ Interrupt Flag (IF) − It determines whether the external interrupts like keyboard entry, etc., are to be ignored or processed. It disables the<br />external interrupt when the value is 0 and enables interrupts when set to 1.<br />▪ Trap Flag (TF) − It allows setting the operation of the processor in single-step mode. The DEBUG program we used sets the trap flag, so we could<br />step through the execution one instruction at a time.<br />▪ Sign Flag (SF) − It shows the sign of the result of an arithmetic operation. This flag is set according to the sign of a data item following the<br />arithmetic operation. The sign is indicated by the high-order of leftmost bit. A positive result clears the value of SF to 0 and negative result sets it to 1.<br />▪ Zero Flag (ZF) − It indicates the result of an arithmetic or comparison operation. A nonzero result clears the zero flag to 0, and a zero result sets<br />it to 1.<br />▪ Auxiliary Carry Flag (AF) − It contains the carry from bit 3 to bit 4 following an arithmetic operation; used for specialized arithmetic. The AF is<br />set when a 1-byte arithmetic operation causes a carry from bit 3 into bit 4.<br />▪ Parity Flag (PF) − It indicates the total number of 1-bits in the result obtained from an arithmetic operation. An even number of 1-bits clears the<br />parity flag to 0 and an odd number of 1-bits sets the parity flag to 1.<br />▪ Carry Flag (CF) − It contains the carry of 0 or 1 from a high-order bit (leftmost) after an arithmetic operation. It also stores the contents of last bit<br />of a shift or rotate operation.<br /><br /><br /><br />There are three main segments <br />▪ Code Segment − It contains all the instructions to be executed. A 16-bit Code Segment register or CS register stores the starting address of the<br />code segment.<br />▪ Data Segment − It contains data, constants and work areas. A 16-bit Data Segment register or DS register stores the starting address of the data<br />segment.<br />▪ Stack Segment − It contains data and return addresses of procedures or subroutines. It is implemented as a &#39;stack&#39; data structure. The Stack<br />Segment register or SS register stores the starting address of the stack.<br /><br />Apart from the DS, CS and SS registers, there are other extra segment registers - ES (extra segment), FS and GS, which provide additional segments for<br />storing data.<br /><br />In assembly programming, a program needs to access the memory locations. All memory locations within a segment are relative to the starting address<br />of the segment. A segment begins in an address evenly divisible by 16 or hexadecimal 10. So, the rightmost hex digit in all such memory addresses is<br />0, which is not generally stored in the segment registers.<br /><br />The segment registers stores the starting addresses of a segment. To get the exact location of data or instruction within a segment, an offset value (or<br />displacement) is required. To reference any memory location in a segment, the processor combines the segment address in the segment register with<br />the offset value of the location.<br /><br /><br /><br /><h1>Linux System Calls</h1><br /><br />You need to take the following steps for using Linux system calls in your program −<br />▪ Put the system call number in the EAX register.<br />▪ Store the arguments to the system call in the registers EBX, ECX, etc.<br />▪ Call the relevant interrupt (80h).<br />▪ The result is usually returned in the EAX register.<br /><br />There are six registers that store the arguments of the system call used. These are the EBX, ECX, EDX, ESI, EDI, and EBP. These registers take the<br />consecutive arguments, starting with the EBX register. If there are more than six arguments, then the memory location of the first argument is stored in<br />the EBX register.<br /><br />All the syscalls are listed in /usr/include/asm/unistd.h, together with their numbers (the value to put in EAX before you call int 80h)<br /><br /><br /><h1>Addressing Modes</h1><br /><br />When an instruction requires two operands, the first operand is generally the destination, which contains data in a register or memory location and the<br />second operand is the source. Source contains either the data to be delivered (immediate addressing) or the address (in register or memory) of the data.<br />Generally, the source data remains unaltered after the operation.<br /><br />The three basic modes of addressing are :<br />▪ Register addressing<br />▪ Immediate addressing<br />▪ Memory addressing<br /><br /><br /><h1>Register Addressing</h1><br /><br />MOV DX, TAX_RATE ; Register in first operand<br />MOV COUNT, CX ; Register in second operand<br />MOV EAX, EBX ; Both the operands are in registers<br /><br /><br /><h1>Immediate Addressing</h1><br /><br />BYTE_VALUE DB 150 ; A byte value is defined<br />WORD_VALUE DW 300 ; A word value is defined<br />ADD BYTE_VALUE, 65 ; An immediate operand 65 is added<br />MOV AX, 45H ; Immediate constant 45H is transferred to AX<br /><br /><br /><h1>Direct Memory Addressing</h1><br /><br />ADD BYTE_VALUE, DL ; Adds the register in the memory location<br />MOV BX, WORD_VALUE ; Operand from the memory is added to register<br /><br /><br /><h1>Direct-Offset Addressing</h1><br /><br />BYTE_TABLE DB 14, 15, 22, 45 ; Tables of bytes<br />WORD_TABLE DW 134, 345, 564, 123 ; Tables of words<br />MOV CL, BYTE_TABLE[2] ; Gets the 3rd element of the BYTE_TABLE<br />MOV CL, BYTE_TABLE + 2 ; Gets the 3rd element of the BYTE_TABLE<br />MOV CX, WORD_TABLE[3] ; Gets the 4th element of the WORD_TABLE<br />MOV CX, WORD_TABLE + 3 ; Gets the 4th element of the WORD_TABLE<br /><br /><br /><h1>Indirect Memory Addressing<br /></h1><br />MY_TABLE TIMES 10 DW 0 ; Allocates 10 words (2 bytes) each initialized to 0<br />MOV EBX, [MY_TABLE] ; Effective Address of MY_TABLE in EBX<br />MOV [EBX], 110 ; MY_TABLE[0] = 110<br />ADD EBX, 2 ; EBX = EBX +2<br />MOV [EBX], 123 ; MY_TABLE[1] = 123<br /><br /><br /><h1>MOV Instruction</h1><br /><br />MOV register, register<br />MOV register, immediate<br />MOV memory, immediate<br />MOV register, memory<br />MOV memory, register<br />▪ Both the operands in MOV operation should be of same size<br />▪ The value of source operand remains unchanged<br />MOV EBX, [MY_TABLE] ; Effective Address of MY_TABLE in EBX<br />MOV [EBX], 110 ; MY_TABLE[0] = 110<br /><br />type specifier<br />:<br /><br />Type Specifier	Bytes addressed<br />BYTE	1<br />WORD	2<br />DWORD	4<br />QWORD	8<br />TBYTE	10<br /><br /><br /><br /><br /><h1>Variables</h1><br /><br /><br />There are five basic forms of the define directive :<br /><br />Directive	Purpose	Storage Space<br />DB	Define Byte	allocates 1 byte<br />DW	Define Word	allocates 2 bytes<br />DD	Define Doubleword	allocates 4 bytes<br />DQ	Define Quadword	allocates 8 bytes<br />DT	Define Ten Bytes	allocates 10 bytes<br /><br /><br />Following are some examples of using define directives :<br />choice DB &#39;y&#39;<br />number DW 12345<br />neg_number DW -12345<br />big_number DQ 123456789<br />real_number1 DD 1.234<br />real_number2 DQ 123.456<br /><br />There are five basic forms of the reserve directive :<br /><br />Directive	Purpose<br />RESB	Reserve a Byte<br />RESW	Reserve a Word<br />RESD	Reserve a Doubleword<br />RESQ	Reserve a Quadword<br />REST	Reserve a Ten Bytes<br /><br /><br /><br />Multiple Definitions<br /><br />You can have multiple data definition statements in a program. For example :<br /><br />choice DB &#39;Y&#39; ;ASCII of y = 79H<br />number1 DW 12345 ;12345D = 3039H<br />number2 DD 12345679 ;123456789D = 75BCD15HThe assembler allocates contiguous memory for multiple variable definitions.<br /><br />Multiple Initializations<br /><br />The TIMES directive allows multiple initializations to the same value. For example, an array named marks of size 9 can be defined and initialized to zero<br />using the following statement :<br /><br />marks TIMES 9 DW 0<br /><br />Constants :<br /><br />EQU Directive<br />The syntax of the EQU directive is as follows :<br />CONSTANT_NAME EQU expression<br /><br />%assign directive<br />The %assign directive can be used to define numeric constants like the EQU directive. This directive allows redefinition. For example, you may define<br />the constant TOTAL as :<br />%assign TOTAL 10<br /><br /><br />%define Directive<br /><br />The %define directive allows defining both numeric and string constants. This directive is similar to the #define in C. For example, you may define the<br />constant PTR as :<br /><br />%define PTR [EBP+4]<br /><br />Arithmetic operations :<br /><br /><br />The INC instruction has the following syntax :<br />INC destination<br /><br />The DEC instruction has the following syntax :<br />DEC destination<br /><br />The ADD and SUB instructions have the following syntax :<br />ADD/SUB destination, source<br /><br />The syntax for the MUL/IMUL instructions is as follows :<br />MUL/IMUL multiplier<br /><br />The format for the DIV/IDIV instruction :<br />DIV/IDIV divisor<br /><br /><br />   → When two bytes are multiplied : The multiplicand is in the AL register, and the multiplier is a byte in the memory or in another register. The product is in AX.<br />       High-order 8 bits of the product is stored in AH and the low-order 8 bits are stored in AL.<br /><br />   → When two one-word values are multiplied : The multiplicand should be in the AX register, and the multiplier is a word in memory or another register. For   example, for an instruction like MUL DX, you must store the multiplier in DX and the multiplicand in AX. The resultant product is a doubleword, which will need two registers. The high-order (leftmost) portion gets stored in DX and the lower-order (rightmost) portion gets stored in AX.<br />   <br />   → When two doubleword values are multiplied : When two doubleword values are multiplied, the multiplicand should be in EAX and the multiplier is a doubleword value stored in memory or in another register. The product generated is stored in the EDX:EAX registers, i.e., the high order 32 bits gets stored in the EDX register and the low order 32-bits are stored in the EAX register.<br /><br /><br />1	When the divisor is 1 byte : The dividend is assumed to be in the AX register (16 bits). After division, the quotient goes to the AL register and the remainder goes 	to the AH register.<br />2	When the divisor is 1 word : The dividend is assumed to be 32 bits long and in the DX:AX registers. The high-order 16 bits are in DX and the low-order 16 bits are 	in AX. After division, the 16-bit quotient goes to the AX register and the 16-bit remainder goes to the DX register.<br />3	When the divisor is doubleword : The dividend is assumed to be 64 bits long and in the EDX:EAX registers. The high-order 32 bits are in EDX and the low-order<br />	32 bits are in EAX. After division, the 32-bit quotient goes to the EAX register and the 32-bit remainder goes to the EDX register.<br /><br /><br /><br /><h1>Assembly Logical instructions </h1><br /><br />The format for these instructions :<br />Sr.No.	Instruction	Format<br />1	AND	AND operand1, operand2<br />2	OR	OR operand1, operand2<br />3	XOR	XOR operand1, operand2<br />4	TEST	TEST operand1, operand2<br />5	NOT	NOT operand1<br /><br /><br />These instructions compare or match bits of the operands and set the CF, OF, PF, SF and ZF flags.<br />The AND instruction is used for supporting logical expressions by performing bitwise AND operation. The bitwise AND operation returns 1, if the matching<br />bits from both the operands are 1, otherwise it returns 0.<br />The OR instruction is used for supporting logical expression by performing bitwise OR operation. The bitwise OR operator returns 1, if the matching bits<br />from either or both operands are one.<br />The XOR instruction implements the bitwise XOR operation. The XOR operation sets the resultant bit to 1, if and only if the bits from the operands are<br />different.<br />The TEST instruction works same as the AND operation, but unlike AND instruction, it does not change the first operand.<br /><br /><h1>Conditions :</h1><br /><br />Conditional Instructions	<br />1	Unconditional jump This is performed by the JMP instruction. Conditional execution often involves a transfer of control to the address of an instruction that does not follow the currently executing instruction. Transfer of control may be forward, to execute a new set of instructions or backward, to re-execute the same steps.<br />2	Conditional jump This is performed by a set of jump instructions j&lt;condition&gt; depending upon the condition. The conditional instructions transfer the control by breaking the sequential flow and they do it by changing the offset value in IP.<br /><br /><br /><br /><h1>CMP Instruction </h1><br />The CMP instruction compares two operands. It is generally used in conditional execution. This instruction basically subtracts one operand from the other for<br />comparing whether the operands are equal or not.<br /><br /><br /><h1>Unconditional Jump</h1><br /><br />As mentioned earlier, this is performed by the JMP instruction. Conditional execution often involves a transfer of control to the address of an instruction that does not<br />follow the currently executing instruction.<br /><br />Following are the conditional jump instructions used on signed data used for arithmetic operations :<br />Instruction	Description	Flags tested<br />JE/JZ	Jump Equal or Jump Zero	ZF<br />JNE/JNZ	Jump not Equal or Jump Not Zero	ZF<br />JG/JNLE	Jump Greater or Jump Not Less/Equal	OF, SF, ZF<br />JGE/JNL	Jump Greater/Equal or Jump Not Less	OF, SF<br />JL/JNGE	Jump Less or Jump Not Greater/Equal	OF, SF<br />JLE/JNG	Jump Less/Equal or Jump Not Greater	OF, SF, ZF<br /><br />Following are the conditional jump instructions used on unsigned data used for logical operations :<br />Instruction	Description	Flags tested<br />JE/JZ	Jump Equal or Jump Zero	ZF<br />JNE/JNZ	Jump not Equal or Jump Not Zero	ZF<br />JA/JNBE	Jump Above or Jump Not Below/Equal	CF, ZF<br />JAE/JNB	Jump Above/Equal or Jump Not Below	CF<br />JB/JNAE	Jump Below or Jump Not Above/Equal	CF<br />JBE/JNA	Jump Below/Equal or Jump Not Above	AF, CF<br /><br />The following conditional jump instructions have special uses and check the value of flags :<br />Instruction	Description	Flags tested<br />JXCZ	Jump if CX is Zero	none<br />JC	Jump If Carry	CF<br />JNC	Jump If No Carry	CF<br />JO	Jump If Overflow	OF<br />JNO	Jump If No Overflow	OF<br />JP/JPE	Jump Parity or Jump Parity Even	PF<br />JNP/JPO	Jump No Parity or Jump Parity Odd	PF<br />JS	Jump Sign (negative value)	SF<br />JNS	Jump No Sign (positive value)	SF<br /><br /><br />The syntax for the J&lt;condition&gt; set of instructions :<br />Example :<br />CMP AL, BL<br />JE EQUAL<br />CMP AL, BH<br />JE EQUAL<br />CMP AL, CL<br />JE EQUAL<br />NON_EQUAL: ...<br />EQUAL: ...<br /><br /><br /><h1>Loops :<br /></h1><br /><br />The basic LOOP instruction has the following syntax :<br />LOOP label<br /><br />Where, label is the target label that identifies the target instruction as in the jump instructions. The LOOP instruction assumes that the ECX register contains the<br />loop count. When the loop instruction is executed, the ECX register is decremented and the control jumps to the target label, until the ECX register value, i.e., the<br />counter reaches the value zero.<br /><br />The above code snippet could be written as :<br />mov ECX,10<br />l1:<br />&lt;loop body&gt;<br />loop l1<br /><br />Numbers<br /><br /><br />Numerical data is generally represented in binary system. Arithmetic instructions operate on binary data. When numbers are displayed on screen or entered from<br />keyboard, they are in ASCII form.<br /><br />Decimal numbers can be represented in two forms :<br />▪ ASCII form<br />▪ BCD or Binary Coded Decimal form<br /><br /><br />ASCII Representation<br /><br />In ASCII representation, decimal numbers are stored as string of ASCII characters. For example, the decimal value 1234 is stored as :<br />31 32 33 34HWhere, 31H is ASCII value for 1, 32H is ASCII value for 2, and so on. There are four instructions for processing numbers in ASCII representation :<br /><br />▪ AAA − ASCII Adjust After Addition<br />▪ AAS − ASCII Adjust After Subtraction<br />▪ AAM − ASCII Adjust After Multiplication<br />▪ AAD − ASCII Adjust Before Division<br />These instructions do not take any operands and assume the required operand to be in the AL register.<br /><br /><br /><br /><h1>BCD Representation</h1><br /><br />There are two types of BCD representation :<br />▪ Unpacked BCD representation<br />▪ Packed BCD representation<br /><br />In unpacked BCD representation, each byte stores the binary equivalent of a decimal digit. For example, the number 1234 is stored as :<br />01 02 03 04H<br /><br />There are two instructions for processing these numbers :<br />▪ AAM − ASCII Adjust After Multiplication<br />▪ AAD − ASCII Adjust Before Division<br /><br />The four ASCII adjust instructions, AAA, AAS, AAM, and AAD, can also be used with unpacked BCD representation. In packed BCD representation, each<br />digit is stored using four bits. Two decimal digits are packed into a byte. For example, the number 1234 is stored as :<br /><br />12 34H<br /><br />There are two instructions for processing these numbers :<br />▪ DAA − Decimal Adjust After Addition<br />▪ DAS − decimal Adjust After Subtraction<br /><br />There is no support for multiplication and division in packed BCD representation.<br /><br /><br /><h1>Strings :</h1><br /><br />Generally, we specify the length of the string by either of the two ways :<br />▪ Explicitly storing string length<br />▪ Using a sentinel character<br />▪<br />We can store the string length explicitly by using the $ location counter symbol that represents the current value of the location counter.<br />Alternatively, you can store strings with a trailing sentinel character to delimit a string instead of storing the string length explicitly. The sentinel<br />character should be a special character that does not appear within a string.<br /><br />Each string instruction may require a source operand, a destination operand or both. For 32-bit segments, string instructions use ESI and EDI registers to<br />point to the source and destination operands, respectively.<br />For 16-bit segments, however, the SI and the DI registers are used to point to the source and destination, respectively.<br />There are five basic instructions for processing strings. They are :<br />▪ MOVS − This instruction moves 1 Byte, Word or Doubleword of data from memory location to another.<br />▪ LODS − This instruction loads from memory. If the operand is of one byte, it is loaded into the AL register, if the operand is one word, it is loaded<br />into the AX register and a doubleword is loaded into the EAX register.<br />▪ STOS − This instruction stores data from register (AL, AX, or EAX) to memory.<br />▪ CMPS − This instruction compares two data items in memory. Data could be of a byte size, word or doubleword.<br />▪ SCAS − This instruction compares the contents of a register (AL, AX or EAX) with the contents of an item in memory.<br /><br />These instructions use the ES:DI and DS:SI pair of registers, where DI and SI registers contain valid offset addresses that refers to bytes stored in<br />memory. SI is normally associated with DS (data segment) and DI is always associated with ES (extra segment).<br /><br />The DS:SI (or ESI) and ES:DI (or EDI) registers point to the source and destination operands, respectively. The source operand is assumed to be at DS:SI<br />(or ESI) and the destination operand at ES:DI (or EDI) in memory.<br /><br />For 16-bit addresses, the SI and DI registers are used, and for 32-bit addresses, the ESI and EDI registers are used.<br />The following table provides various versions of string instructions and the assumed space of the operands.<br /><br />Basic Instruction	Operands at	Byte Operation	Word Operation	Double word Operation<br />MOVS	ES:DI, DS:SI	MOVSB	MOVSW	MOVSD<br />LODS	AX, DS:SI	LODSB	LODSW	LODSD<br />STOS	ES:DI, AX	STOSB	STOSW	STOSD<br />CMPS	DS:SI, ES: DI	CMPSB	CMPSW	CMPSD<br />SCAS	ES:DI, AX	SCASB	SCASW	SCASD<br /><br /><br /><br /><h1>Repetition Prefixes<br /></h1><br />The REP prefix, when set before a string instruction, for example - REP MOVSB, causes repetition of the instruction based on a counter placed at the CX<br />register. REP executes the instruction, decreases CX by 1, and checks whether CX is zero. It repeats the instruction processing until CX is zero.<br /><br />The Direction Flag (DF) determines the direction of the operation.<br />▪ Use CLD (Clear Direction Flag, DF = 0) to make the operation left to right.<br />▪ Use STD (Set Direction Flag, DF = 1) to make the operation right to left.<br /><br />The REP prefix also has the following variations:<br />▪ REP: It is the unconditional repeat. It repeats the operation until CX is zero.<br />▪ REPE or REPZ: It is conditional repeat. It repeats the operation while the zero flag indicates equal/zero. It stops when the ZF indicates not equal/zero<br />or when CX is zero.<br />▪ REPNE or REPNZ: It is also conditional repeat. It repeats the operation while the zero flag indicates not equal/zero. It stops when the ZF indicates<br />equal/zero or when CX is decremented to zero.<br /><br /><br /><br /><h1>Arrays :<br /></h1><br />The data definition directives can also be used for defining a one-dimensional array. Let<br />us define a one-dimensional array of numbers:<br />NUMBERS DW 34, 45, 56, 67, 75, 89<br /><br /><br />The above definition declares an array of six words each initialized with the numbers 34, 45, 56, 67, 75, 89. This allocates 2x6 = 12 bytes of consecutive<br />memory space. The symbolic address of the first number will be NUMBERS and that of the second number will be NUMBERS + 2 and so on.<br /><br />You can define an array named inventory of size 8, and initialize all the values with zero, as :<br />INVENTORY DW 0<br />DW 0<br />DW 0<br />DW 0<br />DW 0<br />DW 0<br />DW 0<br />DW 0<br /><br /><br />The TIMES directive can also be used for multiple initializations to the same value. Using TIMES, the INVENTORY array can be<br />defined as:<br /><br />INVENTORY TIMES 8 DW 0<br /><br /><br /><br /><br /><h1>Procedures :</h1><br /><br />Procedures or subroutines are very important in assembly language, as the assembly language programs tend to be large in size. Procedures are<br />identified by a name. Following this name, the body of the procedure is described which performs a well-defined job. End of the procedure is indicated<br />by a return statement.<br /><br /><h1>Syntax</h1><br /><br />Following is the syntax to define a procedure :<br /><br />proc_name:<br />procedure body<br />...<br />ret<br /><br />The procedure is called from another function by using the CALL instruction. The CALL instruction should have the name of the called procedure as an<br />argument as shown below :<br />CALL proc_name<br /><br />The called procedure returns the control to the calling procedure by using the RET instruction.<br /><br /><br /><h1>Stacks Data Structure<br /></h1><br /><br />A stack is an array-like data structure in the memory in which data can be stored and removed from a location called the &#39;top&#39; of the stack. The data that<br />needs to be stored is &#39;pushed&#39; into the stack and data to be retrieved is &#39;popped&#39; out from the stack. Stack is a LIFO data structure, i.e., the data stored<br />first is retrieved last.<br /><br />Assembly language provides two instructions for stack operations: PUSH and POP. These instructions have syntaxes like :<br /><br />PUSH operand<br />POP address/register<br /><br />The memory space reserved in the stack segment is used for implementing stack. The registers SS and ESP (or SP) are used for implementing the stack.<br />The top of the stack, which points to the last data item inserted into the stack is pointed to by the SS:ESP register, where the SS register points to the<br />beginning of the stack segment and the SP (or ESP) gives the offset into the stack segment.<br />The stack implementation has the following characteristics −<br />▪ Only words or doublewords could be saved into the stack, not a byte.<br />▪ The stack grows in the reverse direction, i.e., toward the lower memory address<br />▪ The top of the stack points to the last item inserted in the stack; it points to the lower byte of the last word inserted.<br /><br /><br />As we discussed about storing the values of the registers in the stack before using them for some use; it can be done in following way :<br /><br />; Save the AX and BX registers in the stack<br />PUSH AX<br />PUSH BX<br /><br />; Use the registers for other purpose<br />MOV AX, VALUE1<br />MOV BX, VALUE2<br />...<br />MOV VALUE1, AX<br />MOV VALUE2, BX<br /><br />; Restore the original values<br />POP BX<br />POP AX<br /><br />Recursions :<br /><br /><br />There are two kind of recursion: direct and indirect. In direct recursion, the procedure calls itself and in indirect recursion, the first procedure calls a<br />second procedure, which in turn calls the first procedure.<br /><br />Recursion could be observed in numerous mathematical algorithms. For example, consider the case of calculating the factorial of a number. Factorial of<br />a number is given by the equation :<br /><br />Fact (n) = n * fact (n-1) for n &gt; 0<br /><br />Macros :<br /><br /><br />Writing a macro is another way of ensuring modular programming in assembly language.<br />▪ A macro is a sequence of instructions, assigned by a name and could be used anywhere in the program.<br />▪ In NASM, macros are defined with %macro and %endmacro directives.<br />▪ The macro begins with the %macro directive and ends with the %endmacro directive.<br /><br />The Syntax for macro definition :<br />%macro macro_name number_of_params<br />&lt;macro body&gt;<br />%endmacro<br /><br /><h1>File Management :</h1><br /><br /><br />The system considers any input or output data as stream of bytes. There are three standard file streams :<br />▪ Standard input (stdin),<br />▪ Standard output (stdout), and<br />▪ Standard error (stderr).<br /><br /><h1>File Descriptor :</h1><br />A file descriptor is a 16-bit integer assigned to a file as a file id. When a new file is created or an existing file is opened, the file descriptor is used for<br />accessing the file. File descriptor of the standard file streams - stdin, stdout and stderr are 0, 1 and 2, respectively.<br /><br /><br /><h1>File Pointer<br /></h1><br />A file pointer specifies the location for a subsequent read/write operation in the file in terms of bytes. Each file is considered as a sequence of bytes.<br />Each open file is associated with a file pointer that specifies an offset in bytes, relative to the beginning of the file.<br />When a file is opened, the file pointer is set to zero.<br /><br /><br /><h1>File Handling System Calls</h1><br /><br />The following table briefly describes the system calls related to file handling :<br />%eax	Name	%ebx	%ecx	%edx<br />2	sys_fork+	struct pt_regs	-	-<br />3	sys_read	unsigned int	char *	size_t<br />4	sys_write	unsigned int	const char *	size_t<br />5	sys_open	const char *	int	int<br />6	sys_close	unsigned int	-	-<br />8	sys_creat	const char *	int	-<br />19	sys_lseek	unsigned int	off_t	unsigned int<br /><br /><br />The steps required for using the system calls are same, as we discussed earlier :<br />▪ Put the system call number in the EAX register.<br />▪ Store the arguments to the system call in the registers EBX, ECX, etc.<br />▪ Call the relevant interrupt (80h).<br />▪ The result is usually returned in the EAX register.<br /><br /><br /><h1>Creating and Opening a File</h1><br /><br />For creating and opening a file, perform the following tasks :<br />▪ Put the system call sys_creat() number 8, in the EAX register.<br />▪ Put the filename in the EBX register.<br />▪ Put the file permissions in the ECX register.<br /><br />The system call returns the file descriptor of the created file in the EAX register, in case of error, the error code is in the EAX register.<br /><br /><h1>Opening an Existing File<br /></h1><br />For opening an existing file, perform the following tasks −<br />▪ Put the system call sys_open() number 5, in the EAX register.<br />▪ Put the filename in the EBX register.<br />▪ Put the file access mode in the ECX register.<br />▪ Put the file permissions in the EDX register.<br /><br />The system call returns the file descriptor of the created file in the EAX register, in case of error, the error code is in the EAX register.<br />Among the file access modes, most commonly used are: read-only (0), write-only (1), and read-write (2).<br /><br />Reading from a File<br /><br />For reading from a file, perform the following tasks −<br />▪ Put the system call sys_read() number 3, in the EAX register.<br />▪ Put the file descriptor in the EBX register.<br />▪ Put the pointer to the input buffer in the ECX register.<br />▪ Put the buffer size, i.e., the number of bytes to read, in the EDX register.<br /><br /><br />The system call returns the number of bytes read in the EAX register, in case of error, the error code is in the EAX register.<br /><br /><h1>Writing to a File</h1><br /><br />For writing to a file, perform the following tasks :<br />▪ Put the system call sys_write() number 4, in the EAX register.<br />▪ Put the file descriptor in the EBX register.<br />▪ Put the pointer to the output buffer in the ECX register.<br />▪ Put the buffer size, i.e., the number of bytes to write, in the EDX register.<br /><br /><br />The system call returns the actual number of bytes written in the EAX register, in case of error, the error code is in the EAX register.<br /><br /><h1>Closing a File</h1><br /><br />For closing a file, perform the following tasks :<br />▪ Put the system call sys_close() number 6, in the EAX register.<br />▪ Put the file descriptor in the EBX register.<br /><br />The system call returns, in case of error, the error code in the EAX register.<br /><br /><h1>Updating a File</h1><br /><br />For updating a file, perform the following tasks :<br />▪ Put the system call sys_lseek () number 19, in the EAX register.<br />▪ Put the file descriptor in the EBX register.<br />▪ Put the offset value in the ECX register.<br />▪ Put the reference position for the offset in the EDX register.<br /><br />The reference position could be:<br />▪ Beginning of file - value 0<br />▪ Current position - value 1<br />▪ End of file - value 2<br /><br />The system call returns, in case of error, the error code in the EAX register.<br /><br /><h1>Memory Management :<br /></h1><br /><br />The sys_brk() system call is provided by the kernel, to allocate memory without the need of moving it later. This call allocates memory right behind the application<br />image in the memory. This system function allows you to set the highest available address in the data section.<br /><br />This system call takes one parameter, which is the highest memory address needed to be set. This value is stored in the EBX register.<br />In case of any error, sys_brk() returns -1 or returns the negative error code itself. The following example demonstrates dynamic memory allocation.</div></body></html>